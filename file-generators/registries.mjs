#! /usr/bin/env node

/**
 * This file automatically generates the index registries for all directories specified in `directories` below. It runs automatically when `yarn preflight` runs or you can run it via `yarn genreg`
 */

import { readdirSync, writeFileSync } from 'fs';
import { resolve, extname } from 'path';
import camelCase from 'camelcase';

// Add an * to the end to work with subdirectories
// (make sure you don't add it if you don't want to include subdirectories
// or you'll get 'interesting' results)
const directories = [
  './components/*',
  './lib/helpers',
  './lib/hooks',
  './lib/context'
];

const message = `/***
This file is autogenerated, please do not edit it.
To generate an updated version, please run \`yarn genreg\`

If you register your helper with this index, it can be referenced more easily.

e.g. without registering

  import fetcher from 'lib/helpers/fetcher
  import poster from 'lib/helpers/poster

e.g. with registering

  import { fetcher, poster } from 'lib/helpers'
*/`;

const include = '.ts|.tsx';
const exclude = `index|\\.spec\\.ts|\\.d\\.ts|\\.DS_Store|\\.gitkeep|README\\.md|readme\\.md`;

const generateLines = (directory, parent) => {
  const dir = readdirSync(resolve(directory)).filter(
    (file) => !file.match(exclude)
  );
  // If dir is empty, do nothing
  if (dir.length !== 0) {
    return dir
      .map((file) => {
        const pathString = parent ? `${parent}/${file}` : file;
        if (!file.match(include)) {
          return `export { default as ${camelCase(file, {
            pascalCase: true
          })} } from './${pathString}';`;
        }
        const fileNoExt = pathString.replace(extname(file), '');
        const varName = camelCase(fileNoExt);
        return `export { default as ${varName} } from './${fileNoExt}';`;
      })
      .filter((item) => item)
      .toString()
      .replace(/,/g, '\n');
  } else {
    return '';
  }
};

directories.forEach((directory) => {
  let checkedDir = directory;
  let subdirs = [];
  let lines = '';

  if (directory.includes('*')) {
    checkedDir = directory.replace('/*', '');
    // scan directory for subdirectories
    subdirs = readdirSync(resolve(checkedDir)).filter(
      (file) => !file.match(exclude)
    );
    subdirs.forEach((dir) => {
      const pathString = resolve(`${checkedDir}/${dir}`);
      return (lines += `${generateLines(pathString, dir)}\n`);
    });
  } else {
    lines = generateLines(directory);
  }

  const fileContents = `${message}\n\n${lines}`;
  if (lines) {
    writeFileSync(resolve(checkedDir, `index.ts`), fileContents);
  }
});
